qfunc multiplex(qfuncs: qfunc[] (), select: qnum) {
  repeat (i: qfuncs.len) {
    control (select == i) {
      qfuncs[i]();
    }
  }
}

qfunc my_be(input: qnum<3, UNSIGNED, 0>, block: qbit[4]) {
  rotating_qubit: qbit;
  del_qubit: qbit;
  select: qbit[2];
  packed: qnum<input.size + del_qubit.size, UNSIGNED, 0>;
  within {
    block -> {select, rotating_qubit, del_qubit};
    {input, del_qubit} -> packed;
    inplace_prepare_state([
      0.333333333333333,
      0.333333333333333,
      0.333333333333333,
      0
    ], 0, select);
  } apply {
    multiplex([lambda() {
      RY(3.200424667205658, rotating_qubit);
    }, lambda() {
      RY(0.0, rotating_qubit);
    }, lambda() {
      RY(3.200424667205658, rotating_qubit);
    }], select);
    multiplex([lambda() {
      packed += 0;
    }, lambda() {
      packed += 1;
    }, lambda() {
      packed += 2;
    }], select);
    packed += -1;
  }
}

qfunc main(angles: real[3], output block: qnum, output data: qnum) {
  allocate(4, block);
  encode_in_angle(angles, data);
  my_be(data, block);
}
