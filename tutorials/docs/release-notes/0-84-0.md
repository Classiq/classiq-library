Released on 2025-06-25.

## Upgrade Instructions

-   [Python SDK](../classiq_101/registration_installations.md/#platform-version-updates)
-   The IDE upgrades automatically.

## Enhancements

-   Added new [chemistry functions](../sdk-reference/applications/chemistry.md) to
    the Python SDK for using Hartree-Fock and UCC ansatz in Qmod. In order to
    use them, it is required to install the Python SDK with the extra
    `chemistry` dependency.
-   Qmod functions are represented with a single symbolic definition throughout
    the compilation process when their use of classical parameters allows it.
    This improves compilation time and output QASM code size in many cases.
-   Added a new function, [`multi_suzuki_trotter`](http://docs.classiq.io/latest/qmod-reference/api-reference/functions/core_library/exponentiation/#classiq.qmod.builtins.functions.exponentiation.multi_suzuki_trotter),
    that applies the Suzuki-Trotter decomposition jointly to a sum of Hamiltonians.
-   Added a new syntax for specifying sparse Hamiltonians ([`SparsePauliOp`](http://docs.classiq.io/latest/qmod-reference/api-reference/classical-types/#classiq.qmod.builtins.structs.SparsePauliOp))
    in Qmod's Python embedding. For example: `0.5 * Pauli.Z(0) * Pauli.Y(1) * Pauli.X(2) + 0.8 * Pauli.X(1)`.
    Check out the [documentation](http://docs.classiq.io/latest/qmod-reference/language-reference/classical-types/#hamiltonians)
    for more details.
-   Added a `dataframe` property to ExecutionDetails object. Example usage:

    ```
    with ExecutionSession(qprog) as es:
        result = es.sample()

    df = result.dataframe
    ```

-   Added a new execution primitive [`ExecutionSession.minimize`](../sdk-reference/execution.md/#classiq.execution.ExecutionSession.minimize)
    that encapsulates classical optimization of ansatz parameters.
    The cost function to minimize is specified either as a quantum observable (Hamiltonian) or an arithmetic expression.
    This offers a significant performance advantage compared to executing the same logic on the client side, as it eliminates
    communication overhead. Note that it utilizes a fixed generic minimization scheme (`scipy-COBYLA`).
    In non-trivial cases, you may still need to implement your own optimization logic.
-   The total size of quantum structs can be retrieved using the new
    [`num_qubits` class attribute](http://docs.classiq.io/latest/qmod-reference/language-reference/quantum-types/#attributes_2)
    of `QStruct`.

## Interface Changes

-   Function `sparse_suzuki_trotter` will no longer be supported starting on
    21/7/25 at the earliest. Instead, use `suzuki_trotter`.
-   Function `parametric_suzuki_trotter` will no longer be supported starting on
    21/7/25 at the earliest. Instead, use `multi_suzuki_trotter`.
-   Function `suzuki_trotter` now receives a sparse Hamiltonian ([`SparsePauliOp`](http://docs.classiq.io/latest/qmod-reference/api-reference/classical-types/#classiq.qmod.builtins.structs.SparsePauliOp))
    instead of a list of non-sparse Pauli terms (`CArray[PauliTerm]`).
    Non-sparse pauli terms in `suzuki_trotter` are deprecated, use
    `SparsePauliOp` instead.
-   [`ExecutionSession`](http://docs.classiq.io/latest/sdk-reference/execution/#classiq.execution.ExecutionSession)'s
    `estimate` methods now accept a sparse Hamiltonian ([`SparsePauliOp`](http://docs.classiq.io/latest/qmod-reference/api-reference/classical-types/#classiq.qmod.builtins.structs.SparsePauliOp))
    instead of a list of non-sparse Pauli terms (`CArray[PauliTerm]`).
    Non-sparse pauli terms in `ExecutionSession` will no longer be supported
    starting on 21/7/25 at the earliest. Use `SparsePauliOp` instead.
