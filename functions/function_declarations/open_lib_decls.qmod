// Open library functions
qfunc qft_step(target: qbit[]);
qfunc qft(target: qbit[]);
qfunc qpe_flexible<unitary_with_power: qfunc <arg0: int>()>(phase: qnum);
qfunc qpe<unitary: qfunc ()>(phase: qnum);
qfunc single_pauli<slope: real, offset: real, q1_qfunc: qfunc <theta: real>(target: qbit)>(x: qbit[], q: qbit);
qfunc linear_pauli_rotations<bases: Pauli[], slopes: real[], offsets: real[]>(x: qbit[], q: qbit[]);
qfunc amplitude_estimation<oracle: qfunc (arg0: qbit[]), space_transform: qfunc (arg0: qbit[])>(phase: qnum, packed_vars: qbit[]);
qfunc phase_oracle<predicate: qfunc (arg0: qbit[], arg1: qbit)>(target: qbit[]);
qfunc reflect_about_zero(packed_vars: qbit[]);
qfunc grover_diffuser<space_transform: qfunc (arg0: qbit[])>(packed_vars: qbit[]);
qfunc grover_operator<oracle: qfunc (arg0: qbit[]), space_transform: qfunc (arg0: qbit[])>(packed_vars: qbit[]);
qfunc grover_search<reps: int, oracle: qfunc (arg0: qbit[])>(packed_vars: qbit[]);
qfunc hadamard_transform(target: qbit[]);
qfunc apply_to_all<gate_operand: qfunc (target: qbit)>(target: qbit[]);
qfunc qft_no_swap(qbv: qbit[]);
qfunc _check_msb<ref: int>(x: qbit[], aux: qbit);
qfunc _ctrl_x<ref: int>(ctrl: qbit, aux: qbit);
qfunc qft_space_add_const<value: int>(phi_b: qbit[]);
qfunc cc_modular_add<n: int, a: int>(phi_b: qbit[], c1: qbit, c2: qbit, aux: qbit);
qfunc c_modular_multiply<n: int, a: int>(b: qbit[], x: qbit[], ctrl: qbit, aux: qbit);
qfunc multiswap(x: qbit[], y: qbit[]);
qfunc inplace_c_modular_multiply<n: int, a: int>(x: qbit[], ctrl: qbit, aux: qbit);
qfunc modular_exp<n: int, a: int>(x: qbit[], power: qbit[]);
qfunc allocate_num<num_qubits: int, is_signed: bool, fraction_digits: int>(output out: qnum<num_qubits, is_signed, fraction_digits>);
qfunc qaoa_mixer_layer<b: real>(target: qbit[]);
qfunc qaoa_cost_layer<g: real, hamiltonian: PauliTerm[]>(target: qbit[]);
qfunc qaoa_layer<g: real, b: real, hamiltonian: PauliTerm[]>(target: qbit[]);
qfunc qaoa_init(target: qbit[]);
qfunc qaoa_penalty<num_qubits: int, params_list: real[], hamiltonian: PauliTerm[]>(target: qbit[num_qubits]);
qfunc full_hea<num_qubits: int, is_parametrized: int[], angle_params: real[], connectivity_map: int[][], reps: int, operands_1qubit: qfunc[] <angle: real>(q: qbit), operands_2qubit: qfunc[] <angle: real>(q1: qbit, q2: qbit)>(x: qbit[num_qubits]);
qfunc swap_test(state1: qbit[], state2: qbit[], output test: qbit);
qfunc prepare_ghz_state<size: int>(output q: qbit[]);
qfunc prepare_exponential_state<rate: int>(q: qbit[]);
qfunc prepare_bell_state<state_num: int>(output q: qbit[2]);
qfunc inplace_prepare_int<value: int>(target: qbit[]);
qfunc prepare_int<value: int>(output out: qnum);
qfunc switch<selector: int, cases: qfunc[] ()>();
