// Open library functions
qfunc qpe_flexible(unitary_with_power: qfunc (int), phase: qnum);
qfunc qpe(unitary: qfunc (), phase: qnum);
qfunc _single_pauli(slope: real, offset: real, q1_qfunc: qfunc (theta: real, target: qbit), x: qbit[], q: qbit);
qfunc linear_pauli_rotations(bases: Pauli[], slopes: real[], offsets: real[], x: qbit[], q: qbit[]);
qfunc amplitude_estimation(oracle: qfunc (qbit[]), space_transform: qfunc (qbit[]), phase: qnum, packed_vars: qbit[]);
qfunc phase_oracle(predicate: qfunc (qbit[], qbit), target: qbit[]);
qfunc reflect_about_zero(packed_vars: qbit[]);
qfunc grover_diffuser(space_transform: qfunc (qbit[]), packed_vars: qbit[]);
qfunc grover_operator(oracle: qfunc (qbit[]), space_transform: qfunc (qbit[]), packed_vars: qbit[]);
qfunc grover_search(reps: int, oracle: qfunc (qbit[]), packed_vars: qbit[]);
qfunc hadamard_transform(target: qbit[]);
qfunc apply_to_all(gate_operand: qfunc (target: qbit), target: qbit[]);
qfunc qft_no_swap(qbv: qbit[]);
qfunc qft_space_add_const(value: int, phi_b: qbit[]);
qfunc cc_modular_add(n: int, a: int, phi_b: qbit[], c1: qbit, c2: qbit);
qfunc c_modular_multiply(n: int, a: int, b: qbit[], x: qbit[], ctrl: qbit);
qfunc multiswap(x: qbit[], y: qbit[]);
qfunc inplace_c_modular_multiply(n: int, a: int, x: qbit[], ctrl: qbit);
qfunc modular_exp(n: int, a: int, x: qbit[], power: qbit[]);
qfunc qsvt_step(phase1: real, phase2: real, proj_cnot_1: qfunc (qbit[], qbit), proj_cnot_2: qfunc (qbit[], qbit), u: qfunc (qbit[]), qvar: qbit[], aux: qbit);
qfunc qsvt(phase_seq: real[], proj_cnot_1: qfunc (qbit[], qbit), proj_cnot_2: qfunc (qbit[], qbit), u: qfunc (qbit[]), qvar: qbit[], aux: qbit);
qfunc projector_controlled_phase(phase: real, proj_cnot: qfunc (qbit[], qbit), qvar: qbit[], aux: qbit);
qfunc qsvt_inversion(phase_seq: real[], block_encoding_cnot: qfunc (qbit[], qbit), u: qfunc (qbit[]), qvar: qbit[], aux: qbit);
qfunc allocate_num(num_qubits: int, is_signed: bool, fraction_digits: int, output out: qnum<num_qubits, is_signed, fraction_digits>);
qfunc qaoa_mixer_layer(b: real, target: qbit[]);
qfunc qaoa_cost_layer(g: real, hamiltonian: PauliTerm[], target: qbit[]);
qfunc qaoa_layer(g: real, b: real, hamiltonian: PauliTerm[], target: qbit[]);
qfunc qaoa_init(target: qbit[]);
qfunc qaoa_penalty(num_qubits: int, params_list: real[], hamiltonian: PauliTerm[], target: qbit[num_qubits]);
qfunc full_hea(num_qubits: int, is_parametrized: int[], angle_params: real[], connectivity_map: int[][], reps: int, operands_1qubit: qfunc[] (angle: real, q: qbit), operands_2qubit: qfunc[] (angle: real, q1: qbit, q2: qbit), x: qbit[num_qubits]);
qfunc swap_test(state1: qbit[], state2: qbit[], output test: qbit);
qfunc prepare_uniform_trimmed_state(m: int, q: qbit[]);
qfunc prepare_uniform_interval_state(start: int, end: int, q: qbit[]);
qfunc prepare_ghz_state(size: int, output q: qbit[]);
qfunc prepare_exponential_state(rate: int, q: qbit[]);
qfunc prepare_bell_state(state_num: int, output q: qbit[2]);
qfunc inplace_prepare_int(value: int, target: qbit[]);
qfunc prepare_int(value: int, output out: qnum<floor(log(value, 2)) + 1, False, 0>);
qfunc switch(selector: int, cases: qfunc[] ());
qfunc qct_qst_type1(x: qbit[]);
qfunc qct_qst_type2(x: qbit[], q: qbit);
qfunc qct_type2(x: qbit[]);
qfunc qst_type2(x: qbit[]);
qfunc modular_increment(a: int, x: qnum);
qfunc qft(target: qbit[]);
qfunc _ctrl_x(ref: int, ctrl: qnum, aux: qbit);
qfunc _prepare_uniform_trimmed_state_step(size_lsb: int, ctrl_val: int, lsbs_val: int, ctrl_var: qnum, rotation_var: qbit);
qfunc _qct_d_operator(x: qnum, q: qbit);
qfunc _qct_pi_operator(x: qbit[], q: qbit);
qfunc _check_msb(ref: int, x: qbit[], aux: qbit);
qfunc encode_in_angle(data: real[], output qba: qbit[]);
qfunc encode_on_bloch(data: real[], output qba: qbit[]);
