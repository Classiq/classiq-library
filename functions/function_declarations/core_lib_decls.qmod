// Core library functions
qfunc H(target: qbit);
qfunc X(target: qbit);
qfunc Y(target: qbit);
qfunc Z(target: qbit);
qfunc I(target: qbit);
qfunc S(target: qbit);
qfunc T(target: qbit);
qfunc SDG(target: qbit);
qfunc TDG(target: qbit);
qfunc PHASE<theta: real>(target: qbit);
qfunc RX<theta: real>(target: qbit);
qfunc RY<theta: real>(target: qbit);
qfunc RZ<theta: real>(target: qbit);
qfunc RXX<theta: real>(target: qbit[2]);
qfunc RYY<theta: real>(target: qbit[2]);
qfunc RZZ<theta: real>(target: qbit[2]);
qfunc CH(control: qbit, target: qbit);
qfunc CX(control: qbit, target: qbit);
qfunc CY(control: qbit, target: qbit);
qfunc CZ(control: qbit, target: qbit);
qfunc CRX<theta: real>(control: qbit, target: qbit);
qfunc CRY<theta: real>(control: qbit, target: qbit);
qfunc CRZ<theta: real>(control: qbit, target: qbit);
qfunc CPHASE<theta: real>(control: qbit, target: qbit);
qfunc SWAP(qbit0: qbit, qbit1: qbit);
qfunc IDENTITY(target: qbit[]);
qfunc prepare_state<probabilities: real[], bound: real>(output out: qbit[]);
qfunc prepare_amplitudes<amplitudes: real[], bound: real>(output out: qbit[]);
qfunc unitary<elements: real[][]>(target: qbit[]);
qfunc add(left: qbit[], right: qbit[], output result: qbit[]);
qfunc U<theta: real, phi: real, lam: real, gam: real>(target: qbit);
qfunc CCX(control: qbit[2], target: qbit);
qfunc allocate<num_qubits: int>(output out: qbit[]);
qfunc free(input in: qbit[]);
qfunc single_pauli_exponent<pauli_string: Pauli[], coefficient: real>(qbv: qbit[]);
qfunc bloch_sphere_feature_map<feature_dimension: int>(qbv: qbit[]);
