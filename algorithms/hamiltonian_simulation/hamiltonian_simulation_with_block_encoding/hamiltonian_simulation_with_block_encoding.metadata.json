{
  "friendly_name": "Hamiltonian Simulation With Block Encoding",
  "description": "This notebook demonstrates state‑of‑the‑art Hamiltonian simulation techniques based on block encoding and polynomial transformations of operators. Starting from a concrete two‑qubit Hamiltonian expressed as a sum of Pauli strings, it uses an LCU construction to build a block‑encoding unitary and verifies that this encoding reproduces H|ψ⟩ up to a known scaling factor. A statevector simulator and custom post‑processing are set up to project onto the successful block subspace and compare quantum results with exact classical evolution.\\n\\nThe notebook then implements three Hamiltonian simulation strategies—GQSP, QSVT, and Chebyshev‑LCU (Qubitization)—all derived from the Jacobi–Anger expansion and Chebyshev polynomial approximations of e^{-iHt}. For each method it computes classical signal‑processing angles or coefficients, builds the corresponding quantum circuits using Classiq’s open‑library functions, runs the simulations, and compares the final state to the exact time evolution. Finally, it summarizes resource trade‑offs (qubit count, CX depth, classical preprocessing time, and effective scaling factors) and provides technical notes on block encoding, LCU, walk operators, and generalizations.\\n\\nKey points:\\n- Constructs and verifies a block‑encoding of a Pauli‑sum Hamiltonian via LCU.\\n- Explains Jacobi–Anger–based polynomial approximations for time evolution and how they set circuit degree.\\n- Implements Hamiltonian simulation using GQSP, QSVT, and a Chebyshev‑LCU walk‑operator approach.\\n- Uses statevector post‑selection and overlap metrics to validate each method against classical evolution.\\n- Compares methods in terms of qubit overhead, CX counts, scaling factors, and preprocessing cost.",
  "level": [],
  "problem_domain_tags": [],
  "qmod_type": [],
  "vertical_tags": []
}
