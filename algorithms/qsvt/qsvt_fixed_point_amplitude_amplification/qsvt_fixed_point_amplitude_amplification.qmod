qstruct OracleVars {
  a: qnum<2>;
  b: qnum<1>;
  c: qnum<3>;
}

qfunc initial_state_projector(state: qnum, aux: qbit) {
  within {
    hadamard_transform(state);
  } apply {
    aux ^= state == 0;
  }
}

qfunc target_state_projector(arith_oracle: qfunc (qbit[], qbit), state: qbit[], aux: qbit) {
  arith_oracle(state, aux);
}

qfunc arith_equation(state: OracleVars, res: qbit) {
  res ^= ((state.a + state.b) == 3) and ((state.c - state.a) == 2);
}

qfunc qsvt_fpaa(phase_seq: real[], arith_oracle: qfunc (const OracleVars, qbit), state: OracleVars, output aux: qbit) {
  allocate(aux);
  qsvt(phase_seq, initial_state_projector, lambda(_state, _aux) {
    target_state_projector(arith_equation, _state, _aux);
  }, IDENTITY, state, aux);
}

qfunc main(output state: OracleVars, output aux: qbit) {
  allocate(state);
  hadamard_transform(state);
  qsvt_fpaa([
    3.0045,
    3.1996,
    3.0708,
    3.2276,
    3.0372,
    3.2686,
    2.986,
    3.3348,
    2.896,
    3.4666,
    2.6798,
    3.8995,
    1.3862,
    1.3862,
    3.8995,
    2.6798,
    3.4666,
    2.896,
    3.3348,
    2.986,
    3.2686,
    3.0372,
    3.2276,
    3.0708,
    3.1996,
    (-75.5353)
  ], arith_equation, state, aux);
}
