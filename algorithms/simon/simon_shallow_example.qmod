qfunc simon_qfunc_with_bipartite_s<partition_index: int>(x: qbit[], output res: qbit[]) {
  allocate<x.len>(res);
  repeat (i: x.len - partition_index) {
    CX(x[i], res[i]);
  }
  repeat (i: partition_index - 1) {
<<<<<<< HEAD
<<<<<<< HEAD
    CX(x[(((x.len) - (partition_index)) + 1) + (i)], res[(((x.len) - (partition_index)) + 1) + (i)]);
    CX(x[(x.len) - (partition_index)], res[(((x.len) - (partition_index)) + 1) + (i)]);
=======
    CX(x[((x.len - partition_index) + 1) + i], res[((x.len - partition_index) + 1) + i]);
    CX(x[x.len - partition_index], res[((x.len - partition_index) + 1) + i]);
>>>>>>> 991980ef0472d4a1f0e4f3caa0a1c1046ab9fbeb
=======
    CX(x[((x.len - partition_index) + 1) + i], res[((x.len - partition_index) + 1) + i]);
    CX(x[x.len - partition_index], res[((x.len - partition_index) + 1) + i]);
>>>>>>> f7386d5a02b35677da04846cd26d5ba60930f8cb
  }
}

qfunc simon_qfunc<f_qfunc: qfunc (arg0: qnum, output arg1: qnum)>(x: qnum) {
  res: qnum;
  hadamard_transform(x);
  f_qfunc(x, res);
  hadamard_transform(x);
}

qfunc main(output x: qnum) {
  allocate<6>(x);
  simon_qfunc<lambda(arg0, arg1) {
    simon_qfunc_with_bipartite_s<4>(arg0, arg1);
  }>(x);
}
