// Harrow–Hassidim–Lloyd (HHL) Algorithm for Solving Linear Systems

// This example implements the HHL quantum linear-systems algorithm to solve
//   A |x⟩ = |b⟩
// where A is a Hermitian matrix and |b⟩ is the right-hand-side vector prepared
// as a quantum state.


// In this example, the matrix A is given as a sum of Pauli strings:
//   A = 0.03*X(0)*X(1) + 0.05*Z(0)*Z(1) + 0.02*Y(0)*Y(1) + 0.08*I
// This Pauli decomposition corresponds to the matrix
//   A = [[0.13, 0.00, 0.00, 0.01],
//        [0.00, 0.03, 0.05, 0.00],
//        [0.00, 0.05, 0.03, 0.00],
//        [0.01, 0.00, 0.00, 0.13]]

hamiltonian: SparsePauliOp = SparsePauliOp {
    terms=[
      SparsePauliTerm {
        paulis=[
          IndexedPauli {pauli=1, index=0},
          IndexedPauli {pauli=1, index=1}
        ],
        coefficient=0.03
      },
      SparsePauliTerm {
        paulis=[
          IndexedPauli {pauli=3, index=1},
          IndexedPauli {pauli=3, index=0}
        ],
        coefficient=0.05
      },
      SparsePauliTerm {
        paulis=[
          IndexedPauli {pauli=2, index=0},
          IndexedPauli {pauli=2, index=1}
        ],
        coefficient=0.02
      },
      SparsePauliTerm {
        paulis=[
          IndexedPauli {pauli=0, index=0}
        ],
        coefficient=0.08
      }
    ],
    num_qubits=2
    };

// For the right-hand-side vector |b⟩, we use a normalized vector of size 4.
rhs_vector: real[] = [sqrt(1/6), sqrt(1/6), sqrt(1/6), sqrt(1/2)];

// In our example the matrix A is a sum of commuting Pauli strings.
// We define how to take powers of the Hamiltonian evolution exp(2π A), which is applied
// within the Quantum Phase Estimation. We simply multiply the evolution time by the power value,
// keeping the number of repetitions at 1, since the terms commute.
qfunc powered_suzuki_trotter_commuting_terms(k: int, hamiltonian: SparsePauliOp, qba: qbit[]) {
  suzuki_trotter(hamiltonian, -2*pi* k, 1, 1, qba);
}

// We define a quantum function that assigns eigenvalue inversion to the amplitudes,
// conditioned on an additional indicator qubit being in the |1⟩ state:
// |value⟩|0⟩ -> (C / value)|value⟩|1⟩ + sqrt(1 − (C / value)^2)|value⟩|0⟩.
// The variable `value` is a signed qnum of size 4 with 4 fractional bits,
// and the inversion amplitudes are normalized using the smallest possible value,
// C = 2^(−value.size).
qfunc assign_inversion_size4(const value: qbit[4], indicator: qbit) {
  RY(-0.0157, indicator);
  skip_control { CX(value[0], indicator); }
  RY(-0.0157, indicator);
  skip_control { CX(value[1], indicator); }
  RY(-0.3379, indicator);
  skip_control { CX(value[0], indicator); }
  RY(0.3066, indicator);
  skip_control { CX(value[2], indicator); }
  RY(-0.1047, indicator);
  skip_control { CX(value[0], indicator); }
  RY(-0.1047, indicator);
  skip_control { CX(value[1], indicator); }
  RY(-0.3181, indicator);
  skip_control { CX(value[0], indicator); }
  RY(0.4649, indicator);
  skip_control { CX(value[3], indicator); }
  RY(-0.0475, indicator);
  skip_control { CX(value[0], indicator); }
  RY(-0.0475, indicator);
  skip_control { CX(value[1], indicator); }
  RY(-0.3407, indicator);
  skip_control { CX(value[0], indicator); }
  RY(0.2457, indicator);
  skip_control { CX(value[2], indicator); }
  RY(-0.0939, indicator);
  skip_control { CX(value[0], indicator); }
  RY(-0.0939, indicator);
  skip_control { CX(value[1], indicator); }
  RY(-0.3122, indicator);
  skip_control { CX(value[0], indicator); }
  RY(0.8154, indicator);
  skip_control { CX(value[3], indicator); }
}

qfunc main(output solution: qnum<2, False, 0>, output phase_var: qnum<4, True, 4>, output indicator: qbit) {
  allocate(phase_var);
  allocate(indicator);
  prepare_amplitudes(rhs_vector, 0.0, solution);
  within {
    qpe_flexible(lambda(k) {
      powered_suzuki_trotter_commuting_terms(k, hamiltonian, solution);
    }, phase_var);
  } apply {
    assign_inversion_size4(phase_var, indicator);
  }
}
