qfunc hadamard_transform_expanded___0(target: qbit[3]) {
  repeat (index: 3) {
    H(target[index]);
  }
}

qperm complex_predicate_expanded___0(const x: qnum<3, False, 0>, res: qbit) {
  res ^= max(x & 3, x ^ 4) >= 4;
}

qperm predicate_0_lambda___0_0_expanded___0(const x: qnum<3, False, 0>, y: qbit) {
  complex_predicate_expanded___0(x, y);
}

qperm predicate_1_lambda___0_0_expanded___0(const x: qbit[3], y: qbit) {
  predicate_0_lambda___0_0_expanded___0(x, y);
}

qperm predicate_2_lambda___0_0_expanded___0(x: qbit, const target_captured__phase_oracle__2: qbit[3]) {
  predicate_1_lambda___0_0_expanded___0(target_captured__phase_oracle__2, x);
}

@disable_perm_check
@disable_const_checks(target)
qperm _cond_phase_flip_expanded___0(const target: qbit, const target_captured__phase_oracle__2: qbit[3]) {
  within {
    H(target);
  } apply {
    predicate_2_lambda___0_0_expanded___0(target, target_captured__phase_oracle__2);
  }
}

qperm phase_oracle_expanded___0(const target: qbit[3]) {
  aux: qbit;
  within {
    allocate(1, aux);
    X(aux);
  } apply {
    _cond_phase_flip_expanded___0(aux, target);
  }
}

qfunc deutsch_jozsa_expanded___0(x: qnum<3, False, 0>) {
  within {
    hadamard_transform_expanded___0(x);
  } apply {
    phase_oracle_expanded___0(x);
  }
}

qfunc main(output x: qnum<3, False, 0>) {
  allocate(3, x);
  deutsch_jozsa_expanded___0(x);
}
