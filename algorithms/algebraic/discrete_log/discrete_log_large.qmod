qfunc discrete_log_oracle(g_generator: int, x_element: int, n_modulus: int, alpha: qbit[], beta: qbit[], output func_res: qnum) {
  allocate(ceiling(log(n_modulus, 2)), func_res);
  func_res ^= 1;
  modular_exp(n_modulus, x_element, func_res, alpha);
  modular_exp(n_modulus, g_generator, func_res, beta);
}

qfunc discrete_log(g: int, x: int, N: int, order: int, output alpha: qnum, output beta: qnum, output func_res: qnum) {
  allocate(ceiling(log(order, 2)) + 1, False, ceiling(log(order, 2)) + 1, alpha);
  allocate(ceiling(log(order, 2)) + 1, False, ceiling(log(order, 2)) + 1, beta);
  hadamard_transform(alpha);
  hadamard_transform(beta);
  discrete_log_oracle(g, x, N, alpha, beta, func_res);
  invert {
    qft(alpha);
  }
  invert {
    qft(beta);
  }
}

qfunc main(output alpha: qnum, output beta: qnum, output func_res: qnum) {
  discrete_log(7, 3, 13, 12, alpha, beta, func_res);
}
