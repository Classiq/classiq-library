qstruct EllipticCurvePoint {
  x: qnum<3>;
  y: qnum<3>;
}

qfunc hadamard_transform_expanded___0(target: qbit[3]) {
  repeat (index: 3) {
    H(target[index]);
  }
}

qperm modular_add_constant_inplace_expanded___0(modulus: int, a: int, x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += a;
    temp += -modulus;
  }
  control (carry) {
    x += modulus;
  }
  carry ^= x >= a;
  free(carry);
}

qfunc qft_no_swap_expanded___0(qbv: qbit[4]) {
  repeat (i: 4) {
    H(qbv[i]);
    repeat (j: (4 - i) - 1) {
      CPHASE(pi / (2 ** (j + 1)), qbv[(i + j) + 1], qbv[i]);
    }
  }
}

qfunc qft_expanded___0(target: qbit[4]) {
  repeat (index: 2.0) {
    SWAP(target[index], target[3 - index]);
  }
  qft_no_swap_expanded___0(target);
}

qfunc qft_space_add_const_expanded___0(value: int, phi_b: qbit[4]) {
  repeat (index: 4) {
    PHASE(qft_const_adder_phase(index, value, 4), phi_b[index]);
  }
}

qfunc _check_msb_expanded___0(ref: int, x: qbit[4], aux: qbit) {
  within {
    invert {
      qft_no_swap_expanded___0(x);
    }
  } apply {
    control (x[0] == ref) {
      X(aux);
    }
  }
}

@disable_perm_check
qperm modular_add_qft_space_expanded___0(n: int, a: int, phi_b: qbit[4]) {
  aux: qbit;
  allocate(1, aux);
  qft_space_add_const_expanded___0(a, phi_b);
  skip_control {
    invert {
      qft_space_add_const_expanded___0(n, phi_b);
    }
    _check_msb_expanded___0(1, phi_b, aux);
    control (aux) {
      qft_space_add_const_expanded___0(n, phi_b);
    }
  }
  invert {
    qft_space_add_const_expanded___0(a, phi_b);
  }
  skip_control {
    _check_msb_expanded___0(0, phi_b, aux);
  }
  qft_space_add_const_expanded___0(a, phi_b);
  free(aux);
}

@disable_perm_check
qperm modular_multiply_constant_expanded___0(modulus: int, const x: qnum<3, False, 0>, a: int, y: qnum<4, False, 0>) {
  x_arr: qbit[3];
  within {
    x -> x_arr;
    qft_expanded___0(y);
  } apply {
    repeat (index: 3) {
      control (x_arr[index]) {
        modular_add_qft_space_expanded___0(modulus, (a * (2 ** index)) % modulus, y);
      }
    }
  }
}

qperm multiswap_expanded___0(x: qbit[3], y: qbit[4]) {
  repeat (index: 3) {
    SWAP(x[index], y[index]);
  }
}

@disable_perm_check
qperm modular_multiply_constant_expanded___1(modulus: int, const x: qnum<3, False, 0>, a: int, y: qnum<4, False, 0>) {
  x_arr: qbit[3];
  within {
    x -> x_arr;
    qft_expanded___0(y);
  } apply {
    repeat (index: 3) {
      control (x_arr[index]) {
        modular_add_qft_space_expanded___0(modulus, (a * (2 ** index)) % modulus, y);
      }
    }
  }
}

qperm modular_multiply_constant_inplace_expanded___0(modulus: int, a: int, x: qnum<3, False, 0>) {
  y: qnum<4, False, 0>;
  allocate(4, y);
  modular_multiply_constant_expanded___0(modulus, x, a, y);
  multiswap_expanded___0(x, y);
  invert {
    modular_multiply_constant_expanded___1(modulus, x, mod_inverse(a, modulus), y);
  }
  free(y);
}

qperm modular_to_montgomery_inplace_expanded___0(modulus: int, x: qnum<3, False, 0>) {
  modular_multiply_constant_inplace_expanded___0(modulus, 8 % modulus, x);
}

qperm multiswap_expanded___1(x: qbit[3], y: qbit[3]) {
  repeat (index: 3) {
    SWAP(x[index], y[index]);
  }
}

qperm multiswap_expanded___2(x: qbit[4], y: qbit[4]) {
  repeat (index: 4) {
    SWAP(x[index], y[index]);
  }
}

qperm cyclic_shift_left_expanded___0(reg: qbit[3]) {
  repeat (i: 2) {
    SWAP(reg[(3 - i) - 1], reg[(3 - i) - 2]);
  }
}

qperm cyclic_shift_left_expanded___1(reg: qbit[5]) {
  repeat (i: 4) {
    SWAP(reg[(5 - i) - 1], reg[(5 - i) - 2]);
  }
}

qperm modular_double_inplace_expanded___0(modulus: int, x: qnum<4, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  res_and_carry: qnum<5, True, 0>;
  within {
    {x, carry} -> res_and_carry;
  } apply {
    cyclic_shift_left_expanded___1(res_and_carry);
    res_and_carry += -modulus;
  }
  control (carry) {
    x += modulus;
  }
  carry ^= (x % 2) == 0;
  free(carry);
}

qperm kaliski_iteration_expanded___0(modulus: int, i: int, v: qnum<3, False, 0>, m: qbit[6], u: qnum<3, False, 0>, r: qnum<4, False, 0>, s: qnum<4, False, 0>, a: qbit, b: qbit, f: qbit) {
  control ((v == 0) & f) {
    X(m[i]);
  }
  f ^= m[i];
  control (f & ((u % 2) == 0)) {
    X(a);
  }
  control ((f & (~a)) & ((v % 2) == 0)) {
    X(m[i]);
  }
  b ^= a;
  b ^= m[i];
  control (((u > v) & f) & (~b)) {
    X(a);
    X(m[i]);
  }
  control (a) {
    multiswap_expanded___1(u, v);
    multiswap_expanded___2(r, s);
  }
  control (f & (~b)) {
    v += -u;
    s += r;
  }
  b ^= m[i];
  b ^= a;
  control (f) {
    invert {
      cyclic_shift_left_expanded___0(v);
    }
  }
  modular_double_inplace_expanded___0(2 * modulus, r);
  larger_than_modulus: qbit;
  allocate(1, larger_than_modulus);
  larger_than_modulus ^= r > modulus;
  control (larger_than_modulus) {
    r += -modulus;
  }
  control ((r % 2) == 1) {
    X(larger_than_modulus);
  }
  free(larger_than_modulus);
  control (a) {
    multiswap_expanded___1(u, v);
    multiswap_expanded___2(r, s);
  }
  control ((s % 2) == 0) {
    X(a);
  }
}

qperm apply_to_all_expanded___0(target: qbit[4]) {
  repeat (index: 4) {
    X(target[index]);
  }
}

qperm bitwise_negate_expanded___0(x: qbit[4]) {
  apply_to_all_expanded___0(x);
}

qperm modular_negate_inplace_expanded___0(modulus: int, x: qnum<4, False, 0>) {
  is_all_zeros: qbit;
  allocate(1, is_all_zeros);
  is_all_zeros ^= x == 0;
  control (is_all_zeros) {
    x += modulus;
  }
  x += 15 - modulus;
  is_all_zeros ^= x == 15;
  bitwise_negate_expanded___0(x);
  free(is_all_zeros);
}

qperm modular_add_constant_inplace_expanded___1(modulus: int, a: int, x: qnum<4, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<5, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += a;
    temp += -modulus;
  }
  control (carry) {
    x += modulus;
  }
  carry ^= x >= a;
  free(carry);
}

qperm modular_rsub_inplace_expanded___0(modulus: int, a: int, x: qnum<4, False, 0>) {
  modular_negate_inplace_expanded___0(modulus, x);
  modular_add_constant_inplace_expanded___1(modulus, a, x);
}

qperm modular_montgomery_to_standard_inplace_expanded___0(modulus: int, x: qnum<3, False, 0>) {
  modular_multiply_constant_inplace_expanded___0(modulus, mod_inverse(8 % modulus, modulus), x);
}

qperm modular_inverse_inplace_expanded___0(modulus: int, v: qnum<3, False, 0>, output m: qbit[6]) {
  allocate(6, m);
  modular_to_montgomery_inplace_expanded___0(modulus, v);
  u: qnum<3, False, 0>;
  r: qnum<4, False, 0>;
  s: qnum<4, False, 0>;
  a: qbit;
  b: qbit;
  f: qbit;
  allocate(3, u);
  allocate(4, r);
  allocate(4, s);
  allocate(1, a);
  allocate(1, b);
  allocate(1, f);
  u ^= modulus;
  r ^= 0;
  s ^= 1;
  f ^= 1;
  repeat (i: 6) {
    kaliski_iteration_expanded___0(modulus, i, v, m, u, r, s, a, b, f);
  }
  modular_rsub_inplace_expanded___0(2 * modulus, modulus, r);
  multiswap_expanded___0(v, r);
  m_num: qnum<6, False, 0>;
  m -> m_num;
  control (m_num == 1) {
    s ^= 1;
    u ^= modulus;
  } else {
    u ^= 1;
    s ^= modulus;
  }
  m_num -> m;
  modular_montgomery_to_standard_inplace_expanded___0(modulus, v);
  free(u);
  free(r);
  free(s);
  free(a);
  free(b);
  free(f);
}

qperm modular_add_inplace_expanded___0(modulus: int, const x: qnum<3, False, 0>, y: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {y, carry} -> temp;
  } apply {
    temp += x;
    temp += -modulus;
  }
  control (carry) {
    y += modulus;
  }
  carry ^= y >= x;
  free(carry);
}

qperm cyclic_shift_left_expanded___2(reg: qbit[4]) {
  repeat (i: 3) {
    SWAP(reg[(4 - i) - 1], reg[(4 - i) - 2]);
  }
}

qperm modular_double_inplace_expanded___1(modulus: int, x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  res_and_carry: qnum<4, True, 0>;
  within {
    {x, carry} -> res_and_carry;
  } apply {
    cyclic_shift_left_expanded___2(res_and_carry);
    res_and_carry += -modulus;
  }
  control (carry) {
    x += modulus;
  }
  carry ^= (x % 2) == 0;
  free(carry);
}

qperm modular_multiply_expanded___0(modulus: int, const x: qbit[3], const y: qbit[3], z: qbit[3]) {
  repeat (idx: 3) {
    control (x[(3 - idx) - 1]) {
      modular_add_inplace_expanded___0(modulus, y, z);
    }
    if (idx != 2) {
      modular_double_inplace_expanded___1(modulus, z);
    }
  }
}

qperm modular_square_expanded___0(modulus: int, const x: qbit[3], z: qbit[3]) {
  repeat (i: 2) {
    control (x[(3 - i) - 1]) {
      modular_add_inplace_expanded___0(modulus, x, z);
    }
    modular_double_inplace_expanded___1(modulus, z);
  }
  control (x[0]) {
    modular_add_inplace_expanded___0(modulus, x, z);
  }
}

qperm apply_to_all_expanded___1(target: qbit[3]) {
  repeat (index: 3) {
    X(target[index]);
  }
}

qperm bitwise_negate_expanded___1(x: qbit[3]) {
  apply_to_all_expanded___1(x);
}

qperm modular_negate_inplace_expanded___1(modulus: int, x: qnum<3, False, 0>) {
  is_all_zeros: qbit;
  allocate(1, is_all_zeros);
  is_all_zeros ^= x == 0;
  control (is_all_zeros) {
    x += modulus;
  }
  x += 7 - modulus;
  is_all_zeros ^= x == 7;
  bitwise_negate_expanded___1(x);
  free(is_all_zeros);
}

qperm modular_subtract_inplace_expanded___0(modulus: int, const x: qnum<3, False, 0>, y: qnum<3, False, 0>) {
  modular_negate_inplace_expanded___1(modulus, y);
  modular_add_inplace_expanded___0(modulus, x, y);
}

qperm ec_point_add_expanded___0(ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  m: qbit[6];
  modular_add_constant_inplace_expanded___0(7, 2, ecp.y);
  modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    modular_multiply_expanded___0(7, ecp.x, ecp.y, slope);
  }
  within {
    modular_multiply_expanded___0(7, slope, ecp.x, t0);
  } apply {
    ecp.y ^= t0;
  }
  within {
    modular_square_expanded___0(7, slope, t0);
  } apply {
    modular_subtract_inplace_expanded___0(7, t0, ecp.x);
    modular_negate_inplace_expanded___1(7, ecp.x);
    modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  }
  modular_multiply_expanded___0(7, slope, ecp.x, ecp.y);
  t1: qnum<3, False, 0>;
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    within {
      allocate(3, t1);
      modular_multiply_expanded___0(7, ecp.x, ecp.y, t1);
    } apply {
      slope ^= t1;
    }
  }
  free(slope);
  modular_add_constant_inplace_expanded___0(7, 2, ecp.y);
  modular_negate_inplace_expanded___1(7, ecp.x);
  modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  free(t0);
}

qperm ec_point_add_expanded___1(ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  m: qbit[6];
  modular_add_constant_inplace_expanded___0(7, 6, ecp.y);
  modular_add_constant_inplace_expanded___0(7, 5, ecp.x);
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    modular_multiply_expanded___0(7, ecp.x, ecp.y, slope);
  }
  within {
    modular_multiply_expanded___0(7, slope, ecp.x, t0);
  } apply {
    ecp.y ^= t0;
  }
  within {
    modular_square_expanded___0(7, slope, t0);
  } apply {
    modular_subtract_inplace_expanded___0(7, t0, ecp.x);
    modular_negate_inplace_expanded___1(7, ecp.x);
    modular_add_constant_inplace_expanded___0(7, 6, ecp.x);
  }
  modular_multiply_expanded___0(7, slope, ecp.x, ecp.y);
  t1: qnum<3, False, 0>;
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    within {
      allocate(3, t1);
      modular_multiply_expanded___0(7, ecp.x, ecp.y, t1);
    } apply {
      slope ^= t1;
    }
  }
  free(slope);
  modular_add_constant_inplace_expanded___0(7, 6, ecp.y);
  modular_negate_inplace_expanded___1(7, ecp.x);
  modular_add_constant_inplace_expanded___0(7, 2, ecp.x);
  free(t0);
}

qperm ec_point_add_expanded___2(ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  m: qbit[6];
  modular_add_constant_inplace_expanded___0(7, 5, ecp.y);
  modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    modular_multiply_expanded___0(7, ecp.x, ecp.y, slope);
  }
  within {
    modular_multiply_expanded___0(7, slope, ecp.x, t0);
  } apply {
    ecp.y ^= t0;
  }
  within {
    modular_square_expanded___0(7, slope, t0);
  } apply {
    modular_subtract_inplace_expanded___0(7, t0, ecp.x);
    modular_negate_inplace_expanded___1(7, ecp.x);
    modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  }
  modular_multiply_expanded___0(7, slope, ecp.x, ecp.y);
  t1: qnum<3, False, 0>;
  within {
    modular_inverse_inplace_expanded___0(7, ecp.x, m);
  } apply {
    within {
      allocate(3, t1);
      modular_multiply_expanded___0(7, ecp.x, ecp.y, t1);
    } apply {
      slope ^= t1;
    }
  }
  free(slope);
  modular_add_constant_inplace_expanded___0(7, 5, ecp.y);
  modular_negate_inplace_expanded___1(7, ecp.x);
  modular_add_constant_inplace_expanded___0(7, 0, ecp.x);
  free(t0);
}

qperm ec_scalar_mult_add_expanded___0(ecp: EllipticCurvePoint, k: qbit[3]) {
  control (k[0]) {
    ec_point_add_expanded___0(ecp);
  }
  control (k[1]) {
    ec_point_add_expanded___1(ecp);
  }
  control (k[2]) {
    ec_point_add_expanded___2(ecp);
  }
}

qfunc qft_no_swap_expanded___1(qbv: qbit[3]) {
  repeat (i: 3) {
    H(qbv[i]);
    repeat (j: (3 - i) - 1) {
      CPHASE(pi / (2 ** (j + 1)), qbv[(i + j) + 1], qbv[i]);
    }
  }
}

qfunc qft_expanded___1(target: qbit[3]) {
  repeat (index: 1.5) {
    SWAP(target[index], target[2 - index]);
  }
  qft_no_swap_expanded___1(target);
}

qfunc shor_ecdlp_expanded___0(output x1: qnum<3, False, 3>, output x2: qnum<3, False, 3>, output ecp: EllipticCurvePoint) {
  allocate(3, False, 3, x1);
  allocate(3, False, 3, x2);
  allocate(6, ecp);
  ecp.x ^= 4;
  ecp.y ^= 2;
  hadamard_transform_expanded___0(x1);
  hadamard_transform_expanded___0(x2);
  ec_scalar_mult_add_expanded___0(ecp, x1);
  ec_scalar_mult_add_expanded___0(ecp, x2);
  invert {
    qft_expanded___1(x1);
  }
  invert {
    qft_expanded___1(x2);
  }
}

qfunc main(output x1: qnum<3, False, 3>, output x2: qnum<3, False, 3>, output ecp: EllipticCurvePoint) {
  shor_ecdlp_expanded___0(x1, x2, ecp);
}
