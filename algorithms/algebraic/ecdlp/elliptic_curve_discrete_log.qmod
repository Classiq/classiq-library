qstruct EllipticCurvePoint {
  x: qnum<3>;
  y: qnum<3>;
}

qfunc hadamard_transform_expanded___0(target: qbit[3]) {
  repeat (index: 3) {
    H(target[index]);
  }
}

qfunc _prepare_uniform_trimmed_state_step_expanded___0(size_lsb: int, ctrl_val: int, lsbs_val: int, ctrl_var: qnum, rotation_var: qbit) {
  if (lsbs_val != 0) {
    control (ctrl_var == ctrl_val) {
      RY((((-2) * asin(sqrt(Min(1, (2.0 ** size_lsb) / lsbs_val)))) - 1.5708) + pi, rotation_var);
    }
  }
}

qfunc prepare_uniform_trimmed_state_expanded___0(m: int, q: qbit[3]) {
  hadamard_transform_expanded___0(q);
  if (m < 8) {
    RY((((-2) * asin(sqrt(Min(1, 4.0 / m)))) - 1.5708) + pi, q[2]);
  }
  repeat (i: 2) {
    _prepare_uniform_trimmed_state_step_expanded___0(1 - i, floor((2.0 ** (i - 2.0)) * m), Mod(m, 2 ** (2 - i)), q[2 - i:3], q[1 - i]);
  }
}

qfunc modular_in_place_add_constant_expanded___0(permutable x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += 2;
    temp += -7;
  }
  control (carry) {
    x += 7;
  }
  control (x >= 2) {
    X(carry);
  }
  free(carry);
}

qfunc modular_in_place_add_constant_expanded___1(permutable x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += 0;
    temp += -7;
  }
  control (carry) {
    x += 7;
  }
  control (x >= 0) {
    X(carry);
  }
  free(carry);
}

qfunc _set_value_expanded___0(permutable reg: qnum<3, False, 0>) {
  reg ^= 1;
}

qfunc _set_value_expanded___1(permutable reg: qnum<3, False, 0>) {
  reg ^= 4;
}

qfunc _set_value_expanded___2(permutable reg: qnum<3, False, 0>) {
  reg ^= 5;
}

qfunc _set_value_expanded___3(permutable reg: qnum<3, False, 0>) {
  reg ^= 2;
}

qfunc _set_value_expanded___4(permutable reg: qnum<3, False, 0>) {
  reg ^= 3;
}

qfunc _set_value_expanded___5(permutable reg: qnum<3, False, 0>) {
  reg ^= 6;
}

qfunc mock_inverse_modulus_7_expanded___0(const x: qnum<3, False, 0>, permutable result: qnum<3, False, 0>) {
  control (x == 1) {
    _set_value_expanded___0(result);
  }
  control (x == 2) {
    _set_value_expanded___1(result);
  }
  control (x == 3) {
    _set_value_expanded___2(result);
  }
  control (x == 4) {
    _set_value_expanded___3(result);
  }
  control (x == 5) {
    _set_value_expanded___4(result);
  }
  control (x == 6) {
    _set_value_expanded___5(result);
  }
}

qfunc modular_in_place_add_expanded___0(const x: qnum<3, False, 0>, permutable y: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  res_and_carry: qnum<4, True, 0>;
  within {
    {y, carry} -> res_and_carry;
  } apply {
    res_and_carry += x;
    res_and_carry += -7;
  }
  control (carry) {
    y += 7;
  }
  control (y >= x) {
    X(carry);
  }
  free(carry);
}

qfunc shift_left_expanded___0(permutable reg: qbit[4]) {
  SWAP(reg[3], reg[2]);
  SWAP(reg[2], reg[1]);
  SWAP(reg[1], reg[0]);
}

qfunc modular_in_place_double_expanded___0(permutable x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  res_and_carry: qnum<4, True, 0>;
  within {
    {x, carry} -> res_and_carry;
  } apply {
    shift_left_expanded___0(res_and_carry);
    res_and_carry += -7;
  }
  control (carry) {
    x += 7;
  }
  lsb: qnum<1, False, 0>;
  rest: qnum<2, False, 0>;
  within {
    x -> {lsb, rest};
  } apply {
    X(lsb);
    CX(lsb, carry);
    X(lsb);
  }
  free(carry);
}

qfunc modular_out_of_place_multiply_expanded___0(const x: qbit[3], const y: qbit[3], permutable z: qbit[3]) {
  control (x[2]) {
    modular_in_place_add_expanded___0(y, z);
  }
  modular_in_place_double_expanded___0(z);
  control (x[1]) {
    modular_in_place_add_expanded___0(y, z);
  }
  modular_in_place_double_expanded___0(z);
  control (x[0]) {
    modular_in_place_add_expanded___0(y, z);
  }
}

qfunc apply_to_all_expanded___0(permutable target: qbit[3]) {
  repeat (index: 3) {
    X(target[index]);
  }
}

qfunc check_if_all_zero_expanded___0(permutable x: qbit[3], permutable ancilla: qbit) {
  within {
    apply_to_all_expanded___0(x);
  } apply {
    control (x) {
      X(ancilla);
    }
  }
}

qfunc check_if_all_ones_expanded___0(permutable x: qbit[3], permutable ancilla: qbit) {
  control (x) {
    X(ancilla);
  }
}

qfunc bitwise_negation_expanded___0(permutable arr: qbit[3]) {
  apply_to_all_expanded___0(arr);
}

qfunc modular_in_place_negate_expanded___0(permutable x: qnum<3, False, 0>) {
  is_all_zeros: qbit;
  allocate(1, is_all_zeros);
  check_if_all_zero_expanded___0(x, is_all_zeros);
  control (is_all_zeros) {
    x += 7;
  }
  x += 0;
  check_if_all_ones_expanded___0(x, is_all_zeros);
  bitwise_negation_expanded___0(x);
  free(is_all_zeros);
}

qfunc modular_in_place_subtract_expanded___0(const x: qnum<3, False, 0>, permutable y: qnum<3, False, 0>) {
  modular_in_place_negate_expanded___0(y);
  modular_in_place_add_expanded___0(x, y);
}

qfunc modular_out_of_place_square_expanded___0(const x: qbit[3], permutable z: qbit[3]) {
  anc: qbit;
  allocate(1, anc);
  control (x[2]) {
    X(anc);
  }
  control (anc) {
    modular_in_place_add_expanded___0(x, z);
  }
  control (x[2]) {
    X(anc);
  }
  modular_in_place_double_expanded___0(z);
  control (x[1]) {
    X(anc);
  }
  control (anc) {
    modular_in_place_add_expanded___0(x, z);
  }
  control (x[1]) {
    X(anc);
  }
  modular_in_place_double_expanded___0(z);
  control (x[0]) {
    X(anc);
  }
  control (anc) {
    modular_in_place_add_expanded___0(x, z);
  }
  control (x[0]) {
    X(anc);
  }
  free(anc);
}

qfunc _set_value_expanded___6(permutable reg: qnum<3, False, 0>) {
  reg ^= 1;
}

qfunc mock_inverse_modulus_7_expanded___1(const x: qnum<3, False, 0>, permutable result: qnum<3, False, 0>) {
  control (x == 1) {
    _set_value_expanded___6(result);
  }
  control (x == 2) {
    _set_value_expanded___1(result);
  }
  control (x == 3) {
    _set_value_expanded___2(result);
  }
  control (x == 4) {
    _set_value_expanded___3(result);
  }
  control (x == 5) {
    _set_value_expanded___4(result);
  }
  control (x == 6) {
    _set_value_expanded___5(result);
  }
}

qfunc ec_point_add_expanded___0(permutable ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  t1: qnum<3, False, 0>;
  modular_in_place_add_constant_expanded___0(ecp.y);
  modular_in_place_add_constant_expanded___1(ecp.x);
  within {
    mock_inverse_modulus_7_expanded___0(ecp.x, t0);
  } apply {
    modular_out_of_place_multiply_expanded___0(t0, ecp.y, slope);
  }
  within {
    modular_out_of_place_multiply_expanded___0(slope, ecp.x, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.y);
  }
  within {
    modular_out_of_place_square_expanded___0(slope, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.x);
    modular_in_place_negate_expanded___0(ecp.x);
    modular_in_place_add_constant_expanded___1(ecp.x);
  }
  modular_out_of_place_multiply_expanded___0(slope, ecp.x, ecp.y);
  within {
    mock_inverse_modulus_7_expanded___1(ecp.x, t0);
  } apply {
    within {
      allocate(3, t1);
      modular_out_of_place_multiply_expanded___0(t0, ecp.y, t1);
    } apply {
      modular_in_place_subtract_expanded___0(t1, slope);
    }
  }
  free(slope);
  modular_in_place_add_constant_expanded___0(ecp.y);
  modular_in_place_negate_expanded___0(ecp.x);
  modular_in_place_add_constant_expanded___1(ecp.x);
  free(t0);
}

qfunc modular_in_place_add_constant_expanded___2(permutable x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += 6;
    temp += -7;
  }
  control (carry) {
    x += 7;
  }
  control (x >= 6) {
    X(carry);
  }
  free(carry);
}

qfunc modular_in_place_add_constant_expanded___3(permutable x: qnum<3, False, 0>) {
  carry: qbit;
  allocate(1, carry);
  temp: qnum<4, True, 0>;
  within {
    {x, carry} -> temp;
  } apply {
    temp += 5;
    temp += -7;
  }
  control (carry) {
    x += 7;
  }
  control (x >= 5) {
    X(carry);
  }
  free(carry);
}

qfunc ec_point_add_expanded___1(permutable ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  t1: qnum<3, False, 0>;
  modular_in_place_add_constant_expanded___2(ecp.y);
  modular_in_place_add_constant_expanded___3(ecp.x);
  within {
    mock_inverse_modulus_7_expanded___0(ecp.x, t0);
  } apply {
    modular_out_of_place_multiply_expanded___0(t0, ecp.y, slope);
  }
  within {
    modular_out_of_place_multiply_expanded___0(slope, ecp.x, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.y);
  }
  within {
    modular_out_of_place_square_expanded___0(slope, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.x);
    modular_in_place_negate_expanded___0(ecp.x);
    modular_in_place_add_constant_expanded___2(ecp.x);
  }
  modular_out_of_place_multiply_expanded___0(slope, ecp.x, ecp.y);
  within {
    mock_inverse_modulus_7_expanded___1(ecp.x, t0);
  } apply {
    within {
      allocate(3, t1);
      modular_out_of_place_multiply_expanded___0(t0, ecp.y, t1);
    } apply {
      modular_in_place_subtract_expanded___0(t1, slope);
    }
  }
  free(slope);
  modular_in_place_add_constant_expanded___2(ecp.y);
  modular_in_place_negate_expanded___0(ecp.x);
  modular_in_place_add_constant_expanded___0(ecp.x);
  free(t0);
}

qfunc ec_point_add_expanded___2(permutable ecp: EllipticCurvePoint) {
  slope: qnum<3, False, 0>;
  allocate(3, slope);
  t0: qnum<3, False, 0>;
  allocate(3, t0);
  t1: qnum<3, False, 0>;
  modular_in_place_add_constant_expanded___3(ecp.y);
  modular_in_place_add_constant_expanded___1(ecp.x);
  within {
    mock_inverse_modulus_7_expanded___0(ecp.x, t0);
  } apply {
    modular_out_of_place_multiply_expanded___0(t0, ecp.y, slope);
  }
  within {
    modular_out_of_place_multiply_expanded___0(slope, ecp.x, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.y);
  }
  within {
    modular_out_of_place_square_expanded___0(slope, t0);
  } apply {
    modular_in_place_subtract_expanded___0(t0, ecp.x);
    modular_in_place_negate_expanded___0(ecp.x);
    modular_in_place_add_constant_expanded___1(ecp.x);
  }
  modular_out_of_place_multiply_expanded___0(slope, ecp.x, ecp.y);
  within {
    mock_inverse_modulus_7_expanded___1(ecp.x, t0);
  } apply {
    within {
      allocate(3, t1);
      modular_out_of_place_multiply_expanded___0(t0, ecp.y, t1);
    } apply {
      modular_in_place_subtract_expanded___0(t1, slope);
    }
  }
  free(slope);
  modular_in_place_add_constant_expanded___3(ecp.y);
  modular_in_place_negate_expanded___0(ecp.x);
  modular_in_place_add_constant_expanded___1(ecp.x);
  free(t0);
}

qfunc ec_scalar_mult_add_expanded___0(permutable ecp: EllipticCurvePoint, permutable k: qbit[3]) {
  control (k[0]) {
    ec_point_add_expanded___0(ecp);
  }
  control (k[1]) {
    ec_point_add_expanded___1(ecp);
  }
  control (k[2]) {
    ec_point_add_expanded___2(ecp);
  }
}

qfunc qft_no_swap_expanded___0(qbv: qbit[3]) {
  repeat (i: 3) {
    H(qbv[i]);
    repeat (j: 2 - i) {
      CPHASE(3.1416 * (2.0 ** ((-j) - 1.0)), qbv[(i + j) + 1], qbv[i]);
    }
  }
}

qfunc qft_expanded___0(target: qbit[3]) {
  repeat (index: 1.5) {
    SWAP(target[index], target[2 - index]);
  }
  qft_no_swap_expanded___0(target);
}

qfunc shor_ecdlp_expanded___0(output x1: qnum<3, False, 3>, output x2: qnum<3, False, 3>, permutable output ecp: EllipticCurvePoint) {
  allocate(3, False, 3, x1);
  allocate(3, False, 3, x2);
  allocate(6, ecp);
  ecp.x ^= 4;
  ecp.y ^= 2;
  prepare_uniform_trimmed_state_expanded___0(5, x1);
  prepare_uniform_trimmed_state_expanded___0(5, x2);
  ec_scalar_mult_add_expanded___0(ecp, x1);
  ec_scalar_mult_add_expanded___0(ecp, x2);
  invert {
    qft_expanded___0(x1);
  }
  invert {
    qft_expanded___0(x2);
  }
}

qfunc main(output x1: qnum<3, False, 3>, output x2: qnum<3, False, 3>, permutable output ecp: EllipticCurvePoint) {
  shor_ecdlp_expanded___0(x1, x2, ecp);
}
