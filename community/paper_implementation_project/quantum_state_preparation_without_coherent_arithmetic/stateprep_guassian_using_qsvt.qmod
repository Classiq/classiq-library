qstruct MyQStruct {
  x: qnum<8, UNSIGNED, 8>;
  a1: qbit;
  a2: qbit;
  a3: qbit;
}

qfunc projector_cnot(reg: qnum, aux: qbit) {
  aux ^= reg == 0;
}

qfunc u_sin(x: qbit[], a: qbit) {
  repeat (i: x.len) {
    CRY(2 ** (((-x.len) + i) + 1), x[i], a);
  }
  X(a);
}

qfunc u_f(reg: MyQStruct) {
  within {
    H(reg.a3);
  } apply {
    qsvt_lcu([
      3.1416,
      3.1416,
      3.1414,
      3.1422,
      3.1413,
      3.1354,
      3.1626,
      3.1272,
      3.0653,
      3.3587,
      2.9898,
      2.837,
      3.8564,
      2.7417,
      2.7417,
      3.8564,
      2.837,
      2.9898,
      3.3587,
      3.0653,
      3.1272,
      3.1626,
      3.1354,
      3.1413,
      3.1422,
      3.1414,
      3.1416,
      (-81.6814),
      0.0
    ], [
      3.1416,
      3.1416,
      3.1415,
      3.1416,
      3.1427,
      3.1373,
      3.1442,
      3.1666,
      3.064,
      3.1968,
      3.3173,
      2.6849,
      3.4367,
      3.5405,
      2.3115,
      3.5405,
      3.4367,
      2.6849,
      3.3173,
      3.1968,
      3.064,
      3.1666,
      3.1442,
      3.1373,
      3.1427,
      3.1416,
      3.1415,
      3.1416,
      (-84.823)
    ], lambda(_reg, aux) {
      projector_cnot(_reg[0], aux);
    }, lambda(_reg, aux) {
      projector_cnot(_reg[0], aux);
    }, lambda(_reg) {
      u_sin(_reg[1:_reg.len], _reg[0]);
    }, {reg.a1, reg.x}, reg.a2, reg.a3);
  }
  H(reg.a3);
}

qfunc state_prep(reg: MyQStruct) {
  hadamard_transform(reg.x);
  u_f(reg);
}

qfunc u_amp(reg: MyQStruct) {
  exact_amplitude_amplification(0.3958, lambda(r) {
    reflect_about_zero(r[reg.x.size:r.len]);
  }, lambda(_reg) {
    state_prep(_reg);
  }, {reg.x, reg.a1, reg.a2, reg.a3});
}

qfunc main(output x: qnum, output a1: qbit, output a2: qbit, output a3: qbit) {
  reg: MyQStruct;
  allocate(reg);
  u_amp(reg);
  reg -> {x, a1, a2, a3};
}
